# Journal — 2026-02-19

## What I worked on
I pushed the project from “diagram + plan” into an actually-runnable **BeagleBone base-controller bring-up**: moving to a modern Debian image, restoring reliable USB networking/SSH from macOS, getting the PRU toolchain installed, and iterating on the PRU build/deploy pipeline (including understanding why RPMsg/remoteproc is failing on my current kernel).

---

## Topics covered

### 1) Moved off old Debian images (APT was broken)
I hit `apt` failures pointing at Debian **buster** repos returning 404s. Root cause: Debian 10 (buster) LTS ended June 30, 2024, so those repo paths no longer behave like normal supported releases. :contentReference[oaicite:0]{index=0}  
**Decision:** stop fighting buster; reflash to a modern BeagleBone Debian image (Debian 13 “trixie” family).

---

### 2) USB networking from macOS: making SSH reliable again
On fresh images, macOS would often keep the BeagleBone USB Ethernet interface (`en11`) at a self-assigned `169.254.x.x` address even after trying DHCP.

**What finally worked (repeatable):**
- Treat the BeagleBone as the “known endpoint”:
  - Configure `usb0` to a static **192.168.7.2/24**
  - Run a DHCP server on `usb0` so the Mac can also get a stable address
  - Persist it using `systemd-networkd`

My working persistent config file is:

- `/etc/systemd/network/usb0.network`
  - `Address=192.168.7.2/24`
  - `DHCPServer=on`

This made `usb0` consistently come up as `192.168.7.2`, and I can SSH to `debian@192.168.7.2`.

Also learned/confirmed on the macOS side:
- `networksetup -setdhcp` requires the **Network Service name** (not the hardware port string), so I used `networksetup -listnetworkserviceorder` to map `en11 → TI_AM335x_BeagleBone_Black`, then ran DHCP on that service.

**Related note:** BeagleBone USB gadget networking commonly relies on `bb-usb-gadgets` + `systemd-networkd` working together to configure `usb0`. :contentReference[oaicite:1]{index=1}

---

### 3) “Externally managed” Python environment: fixed install script
When running `install_deps.sh`, I hit:

- `error: externally-managed-environment`

This is expected on modern Debian because PEP 668 marks the system Python environment as externally managed; you’re supposed to use a **venv** (or OS packages) rather than `pip install --user` into the system Python. :contentReference[oaicite:2]{index=2}

**Fix:**
- Updated the dependency install approach to create and use a project-local virtualenv (e.g., `beaglebone/host_daemon/.venv`) and install Python deps into that venv.

---

### 4) PRU toolchain bring-up: compiler OK, SSP missing, then fixed
**Status:**
- `ti-pru-cgt-v2.3` (TI PRU CodeGen Tools: `clpru`, `lnkpru`) is installed and usable.
- `ti-pru-software-v6.3` / `pru-software-support-package` was not available via apt on this image.

**Fix:**
- Cloned TI’s `pru-software-support-package` from git and pointed the build at it with:
  - `PRU_SSP=$HOME/pru-software-support-package`
- Resolved build script expectations by:
  - Ensuring headers were found under the expected include path (AM335x headers live under `include/am335x/`)
  - Providing an AM335x linker command file and setting:
    - `PRU_CMD_FILE=/home/debian/pru-software-support-package/include/am335x-pru.cmd`

After that, `build_pru.sh` started compiling PRU firmware successfully (until RPMsg API mismatches showed up, next section).

---

### 5) PRU firmware compile issues: RPMsg/VirtIO define + API mismatch
Once the build was “unblocked,” compilation failed inside PRU0 firmware with missing symbols like:
- `VIRTIO_ID_RPMSG`, `VIRTIO_RPMSG_F_NS`, `VIRTIO_CONFIG_S_DRIVER_OK`
…and an argument mismatch for `pru_rpmsg_channel()`.

This indicates the PRU RPMsg code is written against a different revision of the PRU RPMsg headers/API than what’s being used now. Next step is to update the PRU firmware’s includes/defines and `pru_rpmsg_channel()` call signature to match the headers provided by the TI SSP revision I cloned.

---

### 6) Deploying PRU firmware via remoteproc: boot fails with “kick method not defined”
After producing PRU ELFs, `deploy_firmware.sh` copies them into place and tries to start PRU via:

- `/sys/class/remoteproc/remoteproc1` (PRU0)
- `/sys/class/remoteproc/remoteproc2` (PRU1)

But boot fails with:
- `.kick method not defined for 4a334000.pru`
- `failed to probe subdevices ... -22`
- `Boot failed: -22`

This exact failure mode is being reported by others running PRU RPMsg examples on newer 6.18/6.19 kernels. :contentReference[oaicite:3]{index=3}

**Important discovery:**
- My `/boot/uEnv.txt` had:
  - `uboot_overlay_pru=AM335X-PRU-UIO-00A0.dtbo`  
  That’s UIO-based PRU access, but my firmware expects RPMsg/virtio style behavior.

Also learned: PRU overlay names (e.g., “4.19-ti”) must match the kernel series you’re running; a “4.19-ti” overlay implies you should be on a 4.19-ti kernel. :contentReference[oaicite:4]{index=4}

---

### 7) Kernel selection reality check (uname_r must exist in /boot)
For the “switch to a known-working TI kernel (ex: 5.10-ti)” plan:
- I checked `/boot/vmlinuz-*` and only had: `6.19.0-bone8`.

So I **cannot** set `uname_r=5.10...` until that kernel is installed (or an image is flashed that includes it). BeagleBoard docs explicitly say: get kernel names from `/boot`, and `uEnv.txt` selects which installed kernel to boot via `uname_r`. :contentReference[oaicite:5]{index=5}

---

### 8) Repo-to-BeagleBone sync workflow (rsync)
I standardized on rsync from my Mac to the BeagleBone over USB Ethernet.

Baseline command I used:
- `rsync -avh --delete ./ debian@192.168.7.2:~/target_dir/`

(And I planned a repo-root sync script that copies only what the BeagleBone needs and excludes build artifacts/venvs/etc.)

---

## Decisions made (current state)
- **OS baseline:** use modern Debian (trixie) images; do not continue on buster because of EOL/repo breakage. :contentReference[oaicite:6]{index=6}
- **USB networking:** lock in `usb0=192.168.7.2/24` with `systemd-networkd` + `DHCPServer=on` for repeatable SSH.
- **Python deps:** install into a project-local venv (PEP 668 compliant). :contentReference[oaicite:7]{index=7}
- **PRU build:** TI CGT toolchain + cloned TI PRU SSP with `PRU_SSP` and `PRU_CMD_FILE` set.
- **PRU deploy:** remoteproc “kick method not defined” is a known issue on newer kernels; likely need either:
  - a kernel/overlay combo known to work with RPMsg, or
  - a non-RPMsg transport strategy for MVP (shared memory/polling), until kernel support is sorted. :contentReference[oaicite:8]{index=8}

---

## Open questions / next work
1. **Fix PRU RPMsg compilation**:
   - Update missing VirtIO defines/includes and align the `pru_rpmsg_channel()` call to current SSP headers.
2. **Resolve remoteproc/RPMsg boot failure** on 6.19:
   - Inspect what PRU overlays exist for this kernel and/or install a compatible TI kernel series that supports RPMsg properly.
3. **Choose the “MVP transport”**:
   - If RPMsg stays blocked, switch to shared memory + polling (or another channel) so encoder/motor control can proceed.
4. **Finalize the “sync + deploy” workflow**:
   - Repo-root `rsync` script + build + deploy + start/stop scripts so iteration is one command.

---

## Key command snippets I used (for later copy/paste)

### Check kernels installed
- `ls -1 /boot/vmlinuz-* | sed 's|.*/vmlinuz-||'`

### Confirm `usb0` config
- `ip -4 addr show usb0`
- `systemctl status systemd-networkd`

### PRU remoteproc inventory
- `ls -l /sys/class/remoteproc/`
- `dmesg | grep -i pru | tail -n 50`

### Why kernel selection matters
- `uEnv.txt` selects `uname_r` from kernels that exist in `/boot`. :contentReference[oaicite:9]{index=9}
